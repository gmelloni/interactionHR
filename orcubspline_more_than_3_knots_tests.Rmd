---
title: "orcubspline_more_than_3_knots"
author: "Hong Xiong"
date: "2023-06-08"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Some modifications to plotINT to add standard plot stuff with ...
plotINT2 <- function(x , xlab = "" , main = "" , log = FALSE
                  , ylab = NULL ,line1 = TRUE,ylim=NULL
                  , color="dodgerblue" , ...){
  if(is.null(ylab)){
    ylab <- colnames(x)[2]
    if(ylab == "LIN"){
      ylab <- "Linear Estimate"
    }
    if(log){
      ylab <- paste0(ylab , " (log scale)")
    }
  }
  if(is.null(ylim)){
    if("CI_L" %in% colnames(x) && "CI_U" %in% colnames(x)){
      ylim <- c(min(x$CI_L , na.rm = TRUE),max(x$CI_U , na.rm = TRUE))
    } else {
      ylim <- c(min(x[ , 2] , na.rm = TRUE),max(x[ , 2] , na.rm = TRUE))
    }
  }
  plot( x$Value , x[ , 2]
        , type="n" , xlab = xlab
        , ylab = ylab
        , log = if(log) "y" else ""
        , ylim = ylim
        , main = main
        , ...)
  if(line1) {
    if(log)
      abline(h=0 , lty = 3 , lwd = 1 , col = "black")
    else
      abline(h=1 , lty = 3 , lwd = 1 , col = "black")
  }
  lines( pspline::sm.spline(x$Value , x[ , 2]) , col = color , lty = 1 , lwd = 3 )
  if("CI_L" %in% colnames(x) && "CI_U" %in% colnames(x)){
    lines( pspline::sm.spline(x$Value , x$CI_L) , col = "darkgray" , lty = 2 , lwd = 2 )
    lines( pspline::sm.spline(x$Value , x$CI_U) , col = "darkgray" , lty = 2 , lwd = 2 )
  }
}

## Bootstrapping Helper Function
.bootrcsHR_knot_more_than_3 <- function(data, idx , x , model , var1 , var2 , k , fixedknot){
  df <- data[idx,]
  mycall <- model$call
  mycall <- pryr::modify_call(mycall , list(data=quote(df)))
  if("cph" %in% class(model) | "lrm" %in% class(model)){
    myformula <- model$sformula
  } else {
    myformula <- model$formula
  }

  mymodel <- eval(mycall)
  coefMod <- coef(mymodel)
  
  if("cph" %in% class(model) | "lrm" %in% class(model)){
    separator <- " * "
    # k is now a constant parameter
    if(!fixedknot){
      k <- mymodel$Design$parms[[var2]]
    }
  } else {
    separator <- ":"
    # need to recreate the knot sequence for object of class coxph
    # remove the rcs part from the names of the variables in case of a class coxph model
    rcsTerm <- grep(":" , grep("rcs\\(" , attributes(mymodel$terms)$term.labels , value = TRUE) , invert = TRUE , value = TRUE)
    names(coefMod) <- gsub(rcsTerm , "" , names(coefMod) , fixed = TRUE)
    indices <- length(grep(paste0("^", var2, "'*$"), names(coefMod)))+1
    if(!fixedknot){
      k <- attributes(rms::rcs(df[[var2]], indices))$parms
    }
  }
  


### Get Iterative Fractions
  k_num = length(k)
  k_num_counter = length(k)

  fraction_list = list()
  j = 1
  while (k_num_counter >2) {
    temp_frac = (k[k_num] - k[j]) / (k[k_num]-k[k_num-1])
    temp_frac_2 = (k[k_num-1] - k[j]) / (k[k_num]-k[k_num-1])
    fraction_list = c(fraction_list,temp_frac)
    fraction_list = c(fraction_list,temp_frac_2)
    j = j + 1
    k_num_counter = k_num_counter - 1
  }
  
### New Variable Definition
  var_list <- c(var1, var2, paste(var1 , var2 , sep = separator),paste(var2 , var1 , sep = separator))
  
  for(i in 1:(length(k)-2)){
    var2_mod <- paste0(var2, paste(rep("'", i), collapse = ""))
    var_list <- c(var_list,
                  paste0(var2_mod),
                  paste(var1, var2_mod, sep = separator),
                  paste(var2_mod, var1, sep = separator))
  }


  myvars <- sort(intersect(var_list, names(coefMod)))

  mycoef <- coefMod[  myvars ]
  mycoefWhich <- sort(sapply( myvars , function(v) which( names(coefMod) %in% v )))

  num_ticks <- length(k)-2
  b <- mycoef[ var1 ]
  a <- NULL
  
  for (i in 0:num_ticks) {
  
  var_name <- paste0(var2, paste(rep("'", i), collapse = ""))

  if (var_name %in% names(mycoef)) {
    a <- c(a, mycoef[var_name])
  }
}

  l <- mycoef[setdiff(setdiff(myvars, c(var1, names(a))), c(var1, names(a)))]
  
### Get Iterative Terms

  k_num = length(k)
  k_num_counter = length(k)
  term_list = list()
  j = 1
  frac_index = 1
  while (k_num_counter >2) {
    numer <- vapply(x , function(i) {
      max(i - k[j],0)^3  - (max(i - k[k_num-1],0)^3)*fraction_list[[frac_index]] + (max(i -             k[k_num],0)^3)*fraction_list[[frac_index+1]]
    } , numeric(1))
    denom <- (k[k_num] - k[1])^2
    numDem <- numer/denom   
    
    term_list = c(term_list,numDem)
    
    k_num_counter = k_num_counter - 1
    frac_index = frac_index + 2
    j = j + 1
  }
  
  n <- length(term_list)
  elements_per_iteration <- length(x)

  subsets <- list()

  for (i in seq(1, n, by = elements_per_iteration)) {
    end <- min(i + elements_per_iteration - 1, n) 
    subsets[[length(subsets) + 1]] <- term_list[i:end]
  }

  sp2 <- vapply(x , function(i) l[1]*i , numeric(1))
  
  for(i in 2:length(l)) {
    sp2 <- sp2 + l[[i]] * unlist(subsets[i-1])
  }
  

  HR <- unname(exp( b + sp2))
}

## OR Spline for More than 3 Knots 

rcsOR_knot_more_than_3 <- function(var2values , model , data=NULL , var1 , var2
                  , ci=TRUE , conf = 0.95 , ci.method = "delta"
                  , ci.boot.method = "perc" , R = 100 , parallel = "multicore" , fixedknot = FALSE , ...) {
  # argg <- c(as.list(environment()), list(...))
  # Check correct class for model
  if( !any( c("lrm","glm","Glm") %in% class(model) ) ){
    stop("Cubic spline Logistic model must be run with rms::lrm, rms::Glm or stats::glm")
  }
  if(any(c("glm","Glm") %in% class(model)) && !"lrm" %in% class(model)){
    if(!"binomial" %in% model$family$family){
      stop("model of class glm but not family binomial")
    } else {
      modelClass <- "glm"
    }
  } else {
    modelClass <- "lrm"
  }
  if(!is.numeric(var2values)){
    stop("var2values must be a numeric vector")
  }
  x <- var2values
  if(missing(data)){
    if(is.null(model$x)){
      if("bootstrap" %in% ci.method || modelClass == "glm"){
        stop("Missing data")
      }
    } else {
      data <- model$x
    }
  }
  if(!all(c(var1,var2) %in% colnames(data) )){
    stop("var1 or var2 not present in the data")
  }
  # Check that var1 is a 0/1, if not check if the mean is 0
  # if(!all(data[[var1]] %in% c(0,1,NA))){
  #   if(!isTRUE(all.equal(mean(data[[var1]] , na.rm =TRUE),0))){
  #     warning("var1 is not centered on 0 nor a 0/1 variable, results are always reported for a 0 to 1 change in var1.")
  #   }
  # }


  coefMod <- coef(model)
  if(modelClass == "lrm" || "Glm" %in% class(model)){
    k <- model$Design$parms[[var2]]
    separator <- " * "
  } else {
    separator <- ":"
    # need to recreate the knot sequence for object of class coxph
    # remove the rcs part from the names of the variables in case of a class coxph model
    rcsTerm <- grep(":" , grep("rcs\\(" , attributes(model$terms)$term.labels , value = TRUE) , invert = TRUE , value = TRUE)
    names(coefMod) <- gsub(rcsTerm , "" , names(coefMod) , fixed = TRUE)
    indices <- length(grep(paste0("^", var2, "'*$"), names(coefMod)))+1
    k <- attributes(rms::rcs(data[[var2]], indices))$parms
  }
### Get Iterative Fractions
  k_num = length(k)
  k_num_counter = length(k)

  fraction_list = list()
  j = 1
  while (k_num_counter >2) {
    temp_frac = (k[k_num] - k[j]) / (k[k_num]-k[k_num-1])
    temp_frac_2 = (k[k_num-1] - k[j]) / (k[k_num]-k[k_num-1])
    fraction_list = c(fraction_list,temp_frac)
    fraction_list = c(fraction_list,temp_frac_2)
    j = j + 1
    k_num_counter = k_num_counter - 1
  }

### New Variable Definition
  var_list <- c(var1, var2, paste(var1 , var2 , sep = separator),paste(var2 , var1 , sep = separator))

  for(i in 1:(length(k)-2)){
    var2_mod <- paste0(var2, paste(rep("'", i), collapse = ""))
    var_list <- c(var_list,
                  paste0(var2_mod),
                  paste(var1, var2_mod, sep = separator),
                  paste(var2_mod, var1, sep = separator))
  }


  myvars <- sort(intersect(var_list, names(coefMod)))

  mycoef <- coefMod[  myvars ]
  mycoefWhich <- sort(sapply( myvars , function(v) which( names(coefMod) %in% v )))

  num_ticks <- length(k)-2
  b <- mycoef[ var1 ]
  a <- NULL
  
  for (i in 0:num_ticks) {

  var_name <- paste0(var2, paste(rep("'", i), collapse = ""))

  if (var_name %in% names(mycoef)) {
    a <- c(a, mycoef[var_name])
  }
}

  l <- mycoef[setdiff(setdiff(myvars, c(var1, names(a))), c(var1, names(a)))]

### Get Iterative Terms

  k_num = length(k)
  k_num_counter = length(k)
  term_list = list()
  j = 1
  frac_index = 1
  while (k_num_counter >2) {
    numer <- vapply(x , function(i) {
      max(i - k[j],0)^3  - (max(i - k[k_num-1],0)^3)*fraction_list[[frac_index]] + (max(i -             k[k_num],0)^3)*fraction_list[[frac_index+1]]
    } , numeric(1))
    denom <- (k[k_num] - k[1])^2
    numDem <- numer/denom   
    
    term_list = c(term_list,numDem)
    
    k_num_counter = k_num_counter - 1
    frac_index = frac_index + 2
    j = j + 1
  }
  
  n <- length(term_list)
  elements_per_iteration <- length(x)

  subsets <- list()

  for (i in seq(1, n, by = elements_per_iteration)) {
    end <- min(i + elements_per_iteration - 1, n) 
    subsets[[length(subsets) + 1]] <- term_list[i:end]
  }

  sp2 <- vapply(x , function(i) l[1]*i , numeric(1))
  
  for(i in 2:length(l)) {
    sp2 <- sp2 + l[[i]] * unlist(subsets[i-1])
  }
  

  OR <- unname(exp( b + sp2))

 if(ci){
    alpha <- qnorm( 1 - (1-conf)/2)
    if(ci.method == "delta"){
      # This creates a vector like x1 , x2 , x3 , x7 , x8
      # that tells you the position of the regressor as it appears in the model
      xNum <- paste0("x" , mycoefWhich)
      last_terms = tail(xNum,k_num-1)
      vcovMod <- vcov(model)
      xNum_var1 <- paste0("x" , mycoefWhich[var1])
      
      for (k in 1:length(subsets)) {
        assign(paste0("formula_terms", k), subsets[k], envir = .GlobalEnv)
        }
      

      ORci <- t(vapply( seq_len(length(x)) , function(i) {
        x_i <- x[i]
       numDems <- length(grep("formula_terms", ls(.GlobalEnv)))

       formula_parts <- c(paste0("~(", xNum_var1, " + ", last_terms[1], "*(", x_i, ")"))
  
       for (j in 1:numDems) {
        if (j!=numDems){
          numDem_i <- unlist(get(paste0("formula_terms", j)))[i]
          formula_parts <- c(formula_parts, paste0("+ ", last_terms[j+1], "*(", numDem_i, ")"))}
        else{
          numDem_i <- unlist(get(paste0("formula_terms", j)))[i]
          formula_parts <- c(formula_parts, paste0("+ ", last_terms[j+1], "*(", numDem_i, "))"))
      }
       }
      formula = paste(formula_parts, collapse = " ")

        SE <- NULL
        try(SE<-msm::deltamethod(as.formula(formula), coefMod, vcovMod), silent = TRUE)
        if(is.null(SE)){
          return(c(OR[i] , NA , NA , NA))
        }
        up<-exp(log(OR[i])+alpha*SE)
        lo<-exp(log(OR[i])-alpha*SE)
        c(OR[i] , lo , up , SE)
      } , numeric(4)))
      ORci <- cbind( Value = x , ORci)
      rownames(ORci) <- x
      colnames(ORci) <- c("Value" , "OR" , "CI_L" , "CI_U" , "SE")
      ORci <- as.data.frame(ORci)
      # class(ORci) <- c("OR" , class(ORci))
      return(ORci)
    } else if(ci.method == "bootstrap"){
      if(missing(parallel)){
        parallel <- "multicore"
      }
      if(missing(R)){
        R <- 100
      }
      myBoot <- boot::boot(data = data, statistic = .bootrcsHR_knot_more_than_3, x = x , model = model
                  , R = R , parallel = parallel, var1 = var1 , var2 = var2 , k = k , fixedknot = fixedknot)
      SE <- apply(myBoot$t , 2 , sd)
      ORci <- t(vapply( seq_len(length(x)) , function(idx) {
        bci <- boot::boot.ci(boot.out = myBoot,  index = idx , type = ci.boot.method , conf = conf)
        if(ci.boot.method %in% "norm"){
          c(bci$t0 , bci$normal[2] , bci$normal[3] , SE = SE[idx])
        } else {
          c(bci$t0 , bci[[4]][4] , bci[[4]][5] , SE = SE[idx])
        }
      } , numeric(4)))
      ORci <- cbind(x , ORci)
      colnames(ORci) <- c("Value" , "OR" , "CI_L" , "CI_U" , "SE")
      rownames(ORci) <- x
      ORci <- as.data.frame(ORci)

      return(ORci)
    } else {
      stop("Only delta and bootstrap are valid CI methods")
    }
  } else {
    OR <- data.frame(Value = x , OR = OR)
    return(OR)
  }
}

####################
# Testing on UMARU #
####################

library(interactionRCS)
library(survival)
library(rms)
library(magrittr)
umaru <- interactionRCS::umaru

## 3 Knots DELTA result
myformula3 <- censor ~ treat*rcs(age, 3) + site + nonwhite + ivdrug
# Find the 3 knots to test if hardcoding works
my3k <- attributes(rms::rcs(umaru$age , 3))$parms
myformula3hard <- censor ~ treat*rcs(age, c(24, 32, 40)) + site + nonwhite + ivdrug
# Try both cph and coxph
mymodel3 <- list(
  model3_lrm = lrm(myformula3 , data = umaru )
  ,model3_glm = glm(myformula3 , data = umaru , family = "binomial")
  ,model3_lrm_hard = lrm(myformula3hard , data = umaru )
  ,model3_glm_hard = glm(myformula3hard , data = umaru , family = "binomial")
)
# Set boundaries
maxmin <- min(umaru$age):max(umaru$age)
# Original
OR_rcs_delta <- lapply(names(mymodel3[c(1,2)]), function(modmod) {
  rcsOR( var2values = maxmin , model = mymodel3[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "delta")
}) %>% setNames(c("Original lrm" , "Original glm"))
# New
OR_rcs_delta2 <- lapply(names(mymodel3) , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel3[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "delta")
}) %>% setNames(names(mymodel3))

pdf("extra/OR_knots3_delta.pdf" , width = 8 , height = 12)
par(mfrow=c(4,2))
for(i in names(OR_rcs_delta)){
  plotINT2(OR_rcs_delta[[i]]  , main = i , ylim = c(0,3))
}
for(i in names(OR_rcs_delta2)){
  plotINT2(OR_rcs_delta2[[i]]  , main = i , ylim = c(0,3))
}
dev.off()

## 3 Knots bootstrap results with fixed and not fixed knots
set.seed(123)
# Original
OR_rcs_delta <- lapply(names(mymodel3[c(2)]), function(modmod) {
  out <- NULL
  try(out <- rcsOR( var2values = maxmin , model = mymodel3[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "bootstrap"))
  return(out)
}) %>% setNames(c("Original glm"))
# New
OR_rcs_delta2 <- lapply(c(names(mymodel3[c(1,2)])) , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel3[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "bootstrap" , fixedknot = FALSE)
}) %>% setNames(c("New lrm" , "New glm"))
OR_rcs_delta3 <- lapply(c(names(mymodel3[c(1,2)])) , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel3[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "bootstrap" , fixedknot = TRUE)
}) %>% setNames(c("New lrm knot fixed" , "New glm knot fixed"))

pdf("extra/OR_knots3_bootstrap.pdf" , width = 8 , height = 12)
par(mfrow=c(4,2))
for(i in names(OR_rcs_delta)){
  plotINT2(OR_rcs_delta[[i]]  , main = i , ylim = c(0,3))
}
for(i in names(OR_rcs_delta2)){
  plotINT2(OR_rcs_delta2[[i]]  , main = i , ylim = c(0,3))
}
for(i in names(OR_rcs_delta3)){
  plotINT2(OR_rcs_delta3[[i]]  , main = i , ylim = c(0,3))
}
dev.off()

# 4 knots
## 4 Knots DELTA result
myformula4 <- censor ~ treat*rcs(age, 4) + site + nonwhite + ivdrug
# Find the 4 knots to test if hardcoding works
my4k <- attributes(rms::rcs(umaru$age , 4))$parms
myformula4hard <- censor ~ treat*rcs(age, c(23, 29, 35 , 43)) + site + nonwhite + ivdrug
# Try both lrm and glm
mymodel4 <- list(
  model4_lrm = lrm(myformula4 , data = umaru )
  ,model4_glm = glm(myformula4 , data = umaru , family = "binomial")
  ,model4_lrm_hard = lrm(myformula4hard , data = umaru )
  ,model4_glm_hard = glm(myformula4hard , data = umaru , family = "binomial")
)
# Set boundaries
maxmin <- min(umaru$age):max(umaru$age)
# New
OR_rcs_delta2 <- lapply(names(mymodel4) , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel4[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "delta")
}) %>% setNames(names(mymodel4))

pdf("extra/OR_knots4_delta.pdf" , width = 8 , height = 12)
par(mfrow=c(2,2))
for(i in names(OR_rcs_delta2)){
  plotINT2(OR_rcs_delta2[[i]]  , main = i , ylim = c(0,3))
}
dev.off()

# Bootstrap
OR_rcs_delta2 <- lapply(names(mymodel4)[1:2] , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel4[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "bootstrap" , R=300)
}) %>% setNames(c("New lrm" , "New glm"))
OR_rcs_delta2f <- lapply(names(mymodel4)[1:2] , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel4[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "bootstrap" , fixedknot = TRUE , R=300)
}) %>% setNames(c("New lrm knot fixed" , "New glm knot fixed"))

pdf("extra/OR_knots4_bootstrap.pdf" , width = 8 , height = 12)
par(mfrow=c(2,2))
for(i in names(OR_rcs_delta2)){
  plotINT2(OR_rcs_delta2[[i]]  , main = i , ylim = c(0,3))
}
for(i in names(OR_rcs_delta2f)){
  plotINT2(OR_rcs_delta2f[[i]]  , main = i , ylim = c(0,3))
}
dev.off()

# 5 knots
## 5 Knots DELTA result
myformula5 <- censor ~ treat*rcs(age, 5) + site + nonwhite + ivdrug
# Find the 5 knots to test if hardcoding works
my5k <- attributes(rms::rcs(umaru$age , 5))$parms
myformula5hard <- censor ~ treat*rcs(age, c(23, 28, 32 , 36 , 43)) + site + nonwhite + ivdrug
# Try both lrm and glm
mymodel5 <- list(
  model5_lrm = lrm(myformula5 , data = umaru )
  ,model5_glm = glm(myformula5 , data = umaru , family = "binomial")
  ,model5_lrm_hard = lrm(myformula5hard , data = umaru )
  ,model5_glm_hard = glm(myformula5hard , data = umaru , family = "binomial")
)
# Set boundaries
maxmin <- min(umaru$age):max(umaru$age)

OR_rcs_delta2 <- lapply(names(mymodel5) , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel5[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "delta")
}) %>% setNames(names(mymodel5))

pdf("extra/OR_knots5_delta.pdf" , width = 8 , height = 12)
par(mfrow=c(2,2))
for(i in names(OR_rcs_delta2)){
  plotINT2(OR_rcs_delta2[[i]]  , main = i , ylim = c(0,6))
}
dev.off()

# Bootstrap
OR_rcs_delta2 <- lapply(names(mymodel5)[1:2] , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel5[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "bootstrap" , R=300)
}) %>% setNames(c("New lrm" , "New glm"))
OR_rcs_delta2f <- lapply(names(mymodel5)[1:2] , function(modmod) {
  rcsOR_knot_more_than_3( var2values = maxmin
                     , model = mymodel5[[modmod]] , data = umaru , var1 ="treat", var2="age" ,ci.method = "bootstrap" , fixedknot = TRUE , R=300)
}) %>% setNames(c("New lrm knot fixed" , "New glm knot fixed"))

pdf("extra/OR_knots5_bootstrap.pdf" , width = 8 , height = 12)
par(mfrow=c(2,2))
for(i in names(OR_rcs_delta2)){
  plotINT2(OR_rcs_delta2[[i]]  , main = i , ylim = c(0,6))
}
for(i in names(OR_rcs_delta2f)){
  plotINT2(OR_rcs_delta2f[[i]]  , main = i , ylim = c(0,6))
}
dev.off()
```
